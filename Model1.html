<!DOCTYPE html>
<html>
<head>
  <title>Summer CAM WDD Using AI</title>
  <!-- Include Bootstrap CSS -->
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css">
  <style>
    main div {
      border: 1px solid black;
      padding: 10px;
      margin-bottom: 10px;
    }
    #div9 {
      background-color: black;
      color: red; /* Updated font color to red */
      padding: 20px;
    }
    footer {
      padding-top: 30px;
      padding-bottom: 20px;
      text-align: center;
    }
    .banner {
      display: flex;
      justify-content: center;
      align-items: center;
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
    }
  </style>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>
<body>
  <div class="banner">
    <h1 class="display-4">Summer CAM WDD Using AI</h1>
  </div>

  <main class="container">
    <!-- Add content inside div1 -->
    <div id="div1">
      <h2>Section 1. What is a linear regression?</h2>
      <ul>
        <li>It tries to find a linear function y=wx+b.</li>
        <li>The linear function tries to fit a collection of number pairs, such as house sales, (sqft, sale price).</li>
        <li>There is no linear function that can accurately fit all number pairs. So, we have to find the 'best' one.</li>
        <li>By being best, we design a so-called cost function, such as mean square error invented by the great Carl Gauss.</li>
        <li>This is what machine learning is doing.
            <br><img src="linearRegression1.jpg" width="400" height="300" alt="Linear Regression Image"></li>
      </ul>
    </div>  

            <!-- Add content inside div2 -->
            <div id="div2">
              <h2>Section 2. The JavaScript libraries to use</h2>
              <p>We will use TensorFlow.js to train the model.</p>
              <p>Click the 'Run' button below to import two JavaScript libraries.</p>
            </div>
      
            <!-- Add content inside div3 -->
      <div id="div3">
        <p>Import <a href="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js">https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js</a> for defining and training models.</p>
        <p>Import <a href="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js">https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js</a> for web browser visualization.</p>
        <button onclick="loadLibraries()">Run</button>
    </div>

        <!-- Add content inside div4 -->
    <div id="div4"></div>

    <!-- Add content inside div5 -->
    <div id="div5">
        <h2>Section 3. Using the dataset from Google</h2>
        <p>We will use a dataset from Google, <a href="https://storage.googleapis.com/tfjs-tutorials/carsData.json">https://storage.googleapis.com/tfjs-tutorials/carsData.json</a>.</p>
        <button onclick="loadDataset()">Load the dataset</button>
      </div>

        <!-- Add content inside div6 -->
    <div id="div6"></div>

    
        <!-- Add content inside div7 -->
        <div id="div7">
            <h2>Section 4. Extract the Miles_per_Gallon and Horsepower</h2>
            <p>We will use only Miles_per_Gallon:value and Horsepower: value for our training.</p>
            <button onclick="extractData()">Extract training dataset</button>
          </div>
      

    <!-- Add content inside div8 -->
    <div id="div8"></div>

        <!-- Add content inside div -->
    <div id="div9a">
      <h2>Section 5. Visualize the training dataset</h2>
      <button onclick="visualizeDataset()">Visualize the training dataset</button>
      <div id="plot"></div>
    </div>
    

     <!-- Add content inside div9 -->
     <div id="div9">
      <h2>Section 6. Define the model</h2>
      <p>We will define a TensorFlow sequential model with one input x and one output y.</p>
      <button onclick="defineModel()">Define the model</button>
    </div>

    <!-- Add content inside div10 -->
    <div id="div10">
      <button onclick="showModelSummary()">Show summary of the model</button>
      <div id="modelSummary"></div>
    </div>

    <!-- Add content inside div11 -->
    <div id="div11">
      <h2>Section 7. Prepare the training set</h2>
      <p>We will prepare the extracted data.</p>
      <ul>
        <li>Convert the extracted data to Tensor</li>
        <li>Shuffle the data</li>
        <li>Normalize to the range between 0 and 1 for fast computation</li>
      </ul>
      <button onclick="prepareDataset()">Prepare the dataset</button>
    </div>

         <!-- Add content inside div12 -->
    <div id="div12">
      <h2>Section 8. Visualize the inputs and labels for training</h2>
      <button onclick="visualizeInputsAndLabels()">Visualize the inputs and labels</button>
      <div id="visualization"></div>
    </div>

     <!-- Add content inside div13 -->
     <div id="div13">
      <h2>Section 9. Train the model</h2>
      <button onclick="trainModel()">Train the model using prepared data</button>
      <div id="trainingPerformance">
      </div>
    </div>

    <!-- Add content inside div14 -->
    <div id="div14">
      <h2>Section 10. Generate the dataset for testing</h2>
      <button onclick="generateTestData()">Generate test data values</button>
      <div id="testResults">
      </div> 
    </div>

   <!-- Add content inside div15 -->
<div id="div15">
  <h2>Section 11. Visualize the predictions</h2>
  <button onclick="visualizePredictions()">Visualize the predictions</button>
  <div id="predictionsPlot"></div>
</div>

    <div id="div16"></div>
    <div id="div17"></div>
    <div id="div18"></div>
    <div id="div19"></div>
    <div id="div20"></div>
    </ul>
    </div>
  </main>

  <!-- Include Bootstrap JavaScript -->
  <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>

    <script>
      var dataset; // Global variable to store the dataset
      var extractedData; // Global variable to store the extracted dataset
      var model; // Global variable to store the TensorFlow model

      function loadLibraries() {
        var script1 = document.createElement('script');
        script1.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.0.0/dist/tf.min.js';
        document.head.appendChild(script1);

        var script2 = document.createElement('script');
        script2.src = 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-vis@1.0.2/dist/tfjs-vis.umd.min.js';
        document.head.appendChild(script2);

        var consoleOutput = document.getElementById('div4');
        consoleOutput.innerHTML = 'Libraries loaded successfully.';
      }

      function loadDataset() {
        fetch('https://storage.googleapis.com/tfjs-tutorials/carsData.json')
          .then(response => response.json())
          .then(data => {
            dataset = data; // Save the dataset to the global variable
            var consoleOutput = document.getElementById('div6');
            var firstTenData = JSON.stringify(data.slice(0, 10)); // Get the first 10 data values
            consoleOutput.innerHTML = firstTenData;
          })
          .catch(error => {
            var consoleOutput = document.getElementById('div6');
            consoleOutput.innerHTML = 'Error loading dataset: ' + error;
          });
      }

      function defineModel() {
        model = tf.sequential();
        model.add(tf.layers.dense({ inputShape: [1], units: 1 }));
        model.add(tf.layers.dense({ units: 1 }));

        var consoleOutput = document.getElementById('div8');
        consoleOutput.innerHTML = 'Model defined successfully.';
      }
    </script>


<script>
  var dataset; // Global variable to store the dataset
  var extractedData; // Global variable to store the extracted dataset
  var model; // Global variable to store the TensorFlow model

  function extractData() {
    if (dataset) {
      extractedData = dataset.map(item => {
        return {
          Miles_per_Gallon: item.Miles_per_Gallon,
          Horsepower: item.Horsepower
        };
      });

      var consoleOutput = document.getElementById('div8');
      var firstTenData = JSON.stringify(extractedData.slice(0, 10)); // Get the first 10 data values of the extracted dataset
      consoleOutput.innerHTML = firstTenData;
    } else {
      var consoleOutput = document.getElementById('div8');
      consoleOutput.innerHTML = 'Dataset not loaded yet.';
    }
  }


      function visualizeDataset() {
        const horsepowerValues = extractedData.map(item => item.Horsepower);
        const mpgValues = extractedData.map(item => item.Miles_per_Gallon);

        const trace = {
            x: horsepowerValues,
            y: mpgValues,
            mode: 'markers',
            type: 'scatter'
        };

        const layout = {
            title: 'Horsepower vs Miles_per_Gallon',
            xaxis: {
                title: 'Horsepower',
                range: [0, 240],
                dtick: 20
            },
            yaxis: {
                title: 'MPG',
                range: [0, 50],
                dtick: 10
            }
        };

        Plotly.newPlot('plot', [trace], layout);
      }
 
  function defineModel() {
    model = tf.sequential();
    model.add(tf.layers.dense({ inputShape: [1], units: 1 }));
    model.add(tf.layers.dense({ units: 1 }));

    var consoleOutput = document.getElementById('div8');
    consoleOutput.innerHTML = 'Model defined successfully.';
  }

  function showModelSummary() {
    if (model) {
      const container = document.getElementById('modelSummary');
      tfvis.show.modelSummary(container, model);    

     } else {
      var consoleOutput = document.getElementById('div8');
      consoleOutput.innerHTML = 'Model not defined yet.';
    }
  }

  function prepareDataset() {
      if (extractedData) {
        // Extract horsepower as inputs and mpg as labels
        const inputs = extractedData.map(d => d.Horsepower);
        const labels = extractedData.map(d => d.Miles_per_Gallon);

        // Convert inputs and labels to TensorFlow tensors with shape [*, 1]
        const inputTensor = tf.tensor2d(inputs, [inputs.length, 1]);
        const labelTensor = tf.tensor2d(labels, [labels.length, 1]);

        // Normalize the data to the range 0 - 1 using min-max scaling
        const inputMax = inputTensor.max();
        const inputMin = inputTensor.min();
        const labelMax = labelTensor.max();
        const labelMin = labelTensor.min();

        const normalizedInputs = inputTensor.sub(inputMin).div(inputMax.sub(inputMin));
        const normalizedLabels = labelTensor.sub(labelMin).div(labelMax.sub(labelMin));

        // Store the normalized tensors and min/max values in the global variable
        preparedData = {
          inputs: normalizedInputs,
          labels: normalizedLabels,
          inputMax: inputMax,
          inputMin: inputMin,
          labelMax: labelMax,
          labelMin: labelMin
        };

        var consoleOutput = document.getElementById('div8');
        consoleOutput.innerHTML = 'Dataset prepared successfully.';
      } else {
        var consoleOutput = document.getElementById('div8');
        consoleOutput.innerHTML = 'Extracted data not available.';
      }
    }

    function visualizeInputsAndLabels() {
      if (preparedData) {
        const { inputs, labels } = preparedData;

        const inputValues = inputs.dataSync();
        const labelValues = labels.dataSync();

        const data = Array.from(inputValues).map((val, i) => ({
          x: val,
          y: labelValues[i]
        }));

        const surface = { name: 'Inputs vs Labels', tab: 'Charts' };
        const options = {
          xLabel: 'Inputs',
          yLabel: 'Labels',
          xAxisDomain: [0, 1],
          yAxisDomain: [0, 1]
        };

        tfvis.render.scatterplot(
          { name: 'Inputs vs Labels', tab: 'Charts' },
          { values: data },
          options
        );
      } else {
        var consoleOutput = document.getElementById('div12');
        consoleOutput.innerHTML = 'Prepared data not available.';
      }
    }

    async function trainModel() {
      if (preparedData && model) {
        const { inputs, labels } = preparedData;

        model.compile({
          optimizer: tf.train.adam(),
          loss: tf.losses.meanSquaredError,
          metrics: ['mse']
        });

        const surface = document.getElementById('trainingPerformance');
        const metrics = ['loss', 'mse'];

        const history = await model.fit(inputs, labels, {
          batchSize: 32,
          epochs: 50,
          shuffle: true,
          validationSplit: 0.2,
          callbacks: tfvis.show.fitCallbacks(surface, metrics, { height: 200, callbacks: ['onEpochEnd'] })
        });

        var consoleOutput = document.getElementById('div13');
        consoleOutput.innerHTML = 'Model trained successfully.';
      } else {
        var consoleOutput = document.getElementById('div13');
        consoleOutput.innerHTML = 'Prepared data or model not available.';
      }
    }


    let testDataInputs = [];
    let testDataPredictions = [];

    function generateTestData() {
        // Define the number of features
        const numFeatures = 1;

        // Generate uniform range of numbers between 0 and 1 for inputs
        const numInputs = 100;
        const inputs = tf.randomUniform([numInputs, numFeatures]);

        // Use the trained model to predict the results
        const predictions = model.predict(inputs);

        // Un-normalize the data by doing the inverse of the min-max scaling
        /*
        const unnormalizedInputs = inputs.mul(inputMax.sub(inputMin)).add(inputMin);
        const unnormalizedPredictions = predictions.mul(outputMax.sub(outputMin)).add(outputMin);
        */
        const unnormalizedInputs = inputs.mul(preparedData.inputMax.sub(preparedData.inputMin)).add(preparedData.inputMin);
        const unnormalizedPredictions = predictions.mul(preparedData.labelMax.sub(preparedData.labelMin)).add(preparedData.labelMin);



        // Save the un-normalized inputs and predictions to global variables
        testDataInputs = unnormalizedInputs.arraySync();
        testDataPredictions = unnormalizedPredictions.arraySync();
    }

    function generateTestData1() {
  if (model && preparedData) {
    const { inputs, labels, inputMax, inputMin, labelMax, labelMin } = preparedData;
    const numFeatures = 1; // Set numFeatures to 1

    // Generate uniform range of numbers between 0 and 1 for inputs
    const testInputs = tf.linspace(0, 1, 100).reshape([100, numFeatures]);

    // Use the trained model to predict the results
    const testPredictions = model.predict(testInputs);

    // Un-normalize the predictions
    const unNormInputs = testInputs.mul(inputMax.sub(inputMin)).add(inputMin);
    const unNormPredictions = testPredictions.mul(labelMax.sub(labelMin)).add(labelMin);

    // Convert tensors to arrays for visualization
    const inputValues = unNormInputs.dataSync();
    const predictionValues = unNormPredictions.dataSync();

    // Prepare data for visualization
    const data = Array.from(inputValues).map((val, i) => ({
      x: val,
      y: predictionValues[i]
    }));

    const layout = {
      title: 'Model Predictions vs Inputs',
      xaxis: {
        title: 'Horsepower'
      },
      yaxis: {
        title: 'Miles_per_Gallon'
      }
    };

    Plotly.newPlot('testResults', [trace], layout);
  } else {
    var consoleOutput = document.getElementById('testResults');
    consoleOutput.innerHTML = 'Model or prepared data not available.';
  }
}


function visualizePredictions() {

/* not from AI --- start*/
const predictedPoints = Array.from(testDataInputs).map((val, i) => {
    return {x: val, y: testDataPredictions[i]}
});

const originalPoints = extractedData.map(d => ({
    x: d.Horsepower, y: d.Miles_per_Gallon,
}));
/* not from AI --- start*/

const data = {
    values: [originalPoints, predictedPoints],
    //values: [extractedData, testDataInputs],
    series: ['Extracted Data', 'Test Data Predictions'],
};
const surface = tfvis.render.scatterplot(
    div15, data, {xLabel: 'X', yLabel: 'Y', height: 300, series: ['Extracted Data', 'Test Data Predictions']}
);
}



function visualizePredictions1() {
 /* not from AI --- start*/
 const predictedPoints = Array.from(testDataInputs).map((val, i) => {
 return {x: val, y: testDataPredictions[i]}
 });
 const originalPoints = extractedData.map(d => ({
 x: d.Horsepower, y: d.Miles_per_Gallon,
 }));
 /* not from AI --- start*/
 const data = {
 values: [originalPoints, predictedPoints],
 series: ['Extracted Data', 'Test Data Predictions'],
 };
 const surface = tfvis.render.scatterplot( 
  div15, data, {xLabel: 'X', yLabel: 'Y', height: 300,
series: ['Extracted Data', 'Test Data Predictions']
 }
 );
 }
  </script>
</main>

<!-- Include Bootstrap JavaScript -->
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/js/bootstrap.min.js"></script>

</body>
</html>